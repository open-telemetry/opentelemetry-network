// Auto-generated by Render: Rust FFI for ebpf_net::agent_internal
#[allow(non_camel_case_types)]
#[allow(non_snake_case)]
#[allow(unused_variables)]
#[allow(unused_imports)]
use crate::JbBlob;

use crate::wire_messages::*;

use core::slice;

#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_dns_packet(
    __dest: *mut u8,
    __dest_len: u32,
    __tstamp: u64,
    sk: u64,
    pkt: JbBlob,
    total_len: u16,
    is_rx: u8,
) {
    assert!(!__dest.is_null(), "dest must not be null");

    // Compute encoded length: fixed struct size + dynamic payload
    let mut __consumed: u32 = 16 as u32;
    __consumed = __consumed.saturating_add(pkt.len as u32);
    assert!(__consumed <= 0xffff, "encoded len must fit in u16");

    let __total_len = (8_u32).saturating_add(__consumed) as usize;
    assert!(
        __total_len == __dest_len as usize,
        "dest len must exactly match computed encoded len"
    );

    // Prepare destination and input slices up front
    let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };
    let __sl_pkt: &[u8] = unsafe { slice::from_raw_parts(pkt.buf as *const u8, pkt.len as usize) };

    // Build fixed header as a stack struct using an initializer expression
    let __wire: jb_agent_internal__dns_packet = jb_agent_internal__dns_packet {
        _rpc_id: 331 as u16,
        _len: __consumed as u16,
        total_len,
        is_rx,
        sk,
    };

    // Copy timestamp and packed header (without struct tail padding)
    let __fixed_len = 8usize + 16 as usize;
    __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
    let __src_struct: &[u8] =
        unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 16 as usize) };
    __dst[8..__fixed_len].copy_from_slice(__src_struct);

    // Append dynamic payloads sequentially
    let mut __off = __fixed_len;
    if !__sl_pkt.is_empty() {
        let __len = __sl_pkt.len();
        let __dst_seg = &mut __dst[__off..__off + __len];
        __dst_seg.copy_from_slice(__sl_pkt);
        __off += __len;
    }
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_reset_tcp_counters(
    __dest: *mut u8,
    __dest_len: u32,
    __tstamp: u64,
    sk: u64,
    bytes_acked: u64,
    packets_delivered: u32,
    packets_retrans: u32,
    bytes_received: u64,
    pid: u32,
) {
    assert!(!__dest.is_null(), "dest must not be null");

    // Compute encoded length: fixed struct size + dynamic payload
    let __consumed: u32 = 40 as u32;

    let __total_len = (8_u32).saturating_add(__consumed) as usize;
    assert!(
        __total_len == __dest_len as usize,
        "dest len must exactly match computed encoded len"
    );

    // Prepare destination and input slices up front
    let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };

    // Build fixed header as a stack struct using an initializer expression
    let __wire: jb_agent_internal__reset_tcp_counters = jb_agent_internal__reset_tcp_counters {
        _rpc_id: 332 as u16,
        packets_delivered,
        sk,
        bytes_acked,
        bytes_received,
        packets_retrans,
        pid,
    };

    // Copy timestamp and packed header (without struct tail padding)
    let __fixed_len = 8usize + 40 as usize;
    __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
    let __src_struct: &[u8] =
        unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 40 as usize) };
    __dst[8..__fixed_len].copy_from_slice(__src_struct);

    // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_new_sock_created(
    __dest: *mut u8,
    __dest_len: u32,
    __tstamp: u64,
    pid: u32,
    sk: u64,
) {
    assert!(!__dest.is_null(), "dest must not be null");

    // Compute encoded length: fixed struct size + dynamic payload
    let __consumed: u32 = 16 as u32;

    let __total_len = (8_u32).saturating_add(__consumed) as usize;
    assert!(
        __total_len == __dest_len as usize,
        "dest len must exactly match computed encoded len"
    );

    // Prepare destination and input slices up front
    let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };

    // Build fixed header as a stack struct using an initializer expression
    let __wire: jb_agent_internal__new_sock_created = jb_agent_internal__new_sock_created {
        _rpc_id: 333 as u16,
        pid,
        sk,
    };

    // Copy timestamp and packed header (without struct tail padding)
    let __fixed_len = 8usize + 16 as usize;
    __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
    let __src_struct: &[u8] =
        unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 16 as usize) };
    __dst[8..__fixed_len].copy_from_slice(__src_struct);

    // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_udp_new_socket(
    __dest: *mut u8,
    __dest_len: u32,
    __tstamp: u64,
    pid: u32,
    sk: u64,
    laddr: *const u8,
    lport: u16,
) {
    assert!(!__dest.is_null(), "dest must not be null");

    // Compute encoded length: fixed struct size + dynamic payload
    let __consumed: u32 = 32 as u32;

    let __total_len = (8_u32).saturating_add(__consumed) as usize;
    assert!(
        __total_len == __dest_len as usize,
        "dest len must exactly match computed encoded len"
    );

    // Prepare destination and input slices up front
    let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };
    let __sl_laddr: &[u8] = unsafe { slice::from_raw_parts(laddr, 16) };

    // Build fixed header as a stack struct using an initializer expression
    let __wire: jb_agent_internal__udp_new_socket = jb_agent_internal__udp_new_socket {
        _rpc_id: 334 as u16,
        lport,
        pid,
        sk,
        laddr: __sl_laddr.try_into().unwrap(),
    };

    // Copy timestamp and packed header (without struct tail padding)
    let __fixed_len = 8usize + 32 as usize;
    __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
    let __src_struct: &[u8] =
        unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 32 as usize) };
    __dst[8..__fixed_len].copy_from_slice(__src_struct);

    // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_udp_destroy_socket(
    __dest: *mut u8,
    __dest_len: u32,
    __tstamp: u64,
    sk: u64,
) {
    assert!(!__dest.is_null(), "dest must not be null");

    // Compute encoded length: fixed struct size + dynamic payload
    let __consumed: u32 = 16 as u32;

    let __total_len = (8_u32).saturating_add(__consumed) as usize;
    assert!(
        __total_len == __dest_len as usize,
        "dest len must exactly match computed encoded len"
    );

    // Prepare destination and input slices up front
    let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };

    // Build fixed header as a stack struct using an initializer expression
    let __wire: jb_agent_internal__udp_destroy_socket = jb_agent_internal__udp_destroy_socket {
        _rpc_id: 335 as u16,
        sk,
    };

    // Copy timestamp and packed header (without struct tail padding)
    let __fixed_len = 8usize + 16 as usize;
    __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
    let __src_struct: &[u8] =
        unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 16 as usize) };
    __dst[8..__fixed_len].copy_from_slice(__src_struct);

    // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_udp_stats(
    __dest: *mut u8,
    __dest_len: u32,
    __tstamp: u64,
    sk: u64,
    raddr: *const u8,
    packets: u32,
    bytes: u32,
    changed_af: u8,
    rport: u16,
    is_rx: u8,
    laddr: *const u8,
    lport: u16,
    drops: u32,
) {
    assert!(!__dest.is_null(), "dest must not be null");

    // Compute encoded length: fixed struct size + dynamic payload
    let __consumed: u32 = 60 as u32;

    let __total_len = (8_u32).saturating_add(__consumed) as usize;
    assert!(
        __total_len == __dest_len as usize,
        "dest len must exactly match computed encoded len"
    );

    // Prepare destination and input slices up front
    let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };
    let __sl_raddr: &[u8] = unsafe { slice::from_raw_parts(raddr, 16) };
    let __sl_laddr: &[u8] = unsafe { slice::from_raw_parts(laddr, 16) };

    // Build fixed header as a stack struct using an initializer expression
    let __wire: jb_agent_internal__udp_stats = jb_agent_internal__udp_stats {
        _rpc_id: 336 as u16,
        rport,
        packets,
        sk,
        bytes,
        drops,
        lport,
        raddr: __sl_raddr.try_into().unwrap(),
        changed_af,
        is_rx,
        laddr: __sl_laddr.try_into().unwrap(),
    };

    // Copy timestamp and packed header (without struct tail padding)
    let __fixed_len = 8usize + 60 as usize;
    __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
    let __src_struct: &[u8] =
        unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 60 as usize) };
    __dst[8..__fixed_len].copy_from_slice(__src_struct);

    // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_pid_info(
    __dest: *mut u8,
    __dest_len: u32,
    __tstamp: u64,
    pid: u32,
    comm: *const u8,
    cgroup: u64,
    parent_pid: i32,
) {
    assert!(!__dest.is_null(), "dest must not be null");

    // Compute encoded length: fixed struct size + dynamic payload
    let __consumed: u32 = 36 as u32;

    let __total_len = (8_u32).saturating_add(__consumed) as usize;
    assert!(
        __total_len == __dest_len as usize,
        "dest len must exactly match computed encoded len"
    );

    // Prepare destination and input slices up front
    let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };
    let __sl_comm: &[u8] = unsafe { slice::from_raw_parts(comm, 16) };

    // Build fixed header as a stack struct using an initializer expression
    let __wire: jb_agent_internal__pid_info = jb_agent_internal__pid_info {
        _rpc_id: 337 as u16,
        comm: __sl_comm.try_into().unwrap(),
        pid,
        cgroup,
        parent_pid,
    };

    // Copy timestamp and packed header (without struct tail padding)
    let __fixed_len = 8usize + 36 as usize;
    __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
    let __src_struct: &[u8] =
        unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 36 as usize) };
    __dst[8..__fixed_len].copy_from_slice(__src_struct);

    // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_pid_close(
    __dest: *mut u8,
    __dest_len: u32,
    __tstamp: u64,
    pid: u32,
    comm: *const u8,
) {
    assert!(!__dest.is_null(), "dest must not be null");

    // Compute encoded length: fixed struct size + dynamic payload
    let __consumed: u32 = 24 as u32;

    let __total_len = (8_u32).saturating_add(__consumed) as usize;
    assert!(
        __total_len == __dest_len as usize,
        "dest len must exactly match computed encoded len"
    );

    // Prepare destination and input slices up front
    let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };
    let __sl_comm: &[u8] = unsafe { slice::from_raw_parts(comm, 16) };

    // Build fixed header as a stack struct using an initializer expression
    let __wire: jb_agent_internal__pid_close = jb_agent_internal__pid_close {
        _rpc_id: 338 as u16,
        comm: __sl_comm.try_into().unwrap(),
        pid,
    };

    // Copy timestamp and packed header (without struct tail padding)
    let __fixed_len = 8usize + 24 as usize;
    __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
    let __src_struct: &[u8] =
        unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 24 as usize) };
    __dst[8..__fixed_len].copy_from_slice(__src_struct);

    // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_pid_set_comm(
    __dest: *mut u8,
    __dest_len: u32,
    __tstamp: u64,
    pid: u32,
    comm: *const u8,
) {
    assert!(!__dest.is_null(), "dest must not be null");

    // Compute encoded length: fixed struct size + dynamic payload
    let __consumed: u32 = 24 as u32;

    let __total_len = (8_u32).saturating_add(__consumed) as usize;
    assert!(
        __total_len == __dest_len as usize,
        "dest len must exactly match computed encoded len"
    );

    // Prepare destination and input slices up front
    let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };
    let __sl_comm: &[u8] = unsafe { slice::from_raw_parts(comm, 16) };

    // Build fixed header as a stack struct using an initializer expression
    let __wire: jb_agent_internal__pid_set_comm = jb_agent_internal__pid_set_comm {
        _rpc_id: 371 as u16,
        comm: __sl_comm.try_into().unwrap(),
        pid,
    };

    // Copy timestamp and packed header (without struct tail padding)
    let __fixed_len = 8usize + 24 as usize;
    __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
    let __src_struct: &[u8] =
        unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 24 as usize) };
    __dst[8..__fixed_len].copy_from_slice(__src_struct);

    // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_set_state_ipv4(
    __dest: *mut u8,
    __dest_len: u32,
    __tstamp: u64,
    dest: u32,
    src: u32,
    dport: u16,
    sport: u16,
    sk: u64,
    tx_rx: u32,
) {
    assert!(!__dest.is_null(), "dest must not be null");

    // Compute encoded length: fixed struct size + dynamic payload
    let __consumed: u32 = 26 as u32;

    let __total_len = (8_u32).saturating_add(__consumed) as usize;
    assert!(
        __total_len == __dest_len as usize,
        "dest len must exactly match computed encoded len"
    );

    // Prepare destination and input slices up front
    let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };

    // Build fixed header as a stack struct using an initializer expression
    let __wire: jb_agent_internal__set_state_ipv4 = jb_agent_internal__set_state_ipv4 {
        _rpc_id: 339 as u16,
        dport,
        dest,
        sk,
        src,
        tx_rx,
        sport,
    };

    // Copy timestamp and packed header (without struct tail padding)
    let __fixed_len = 8usize + 26 as usize;
    __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
    let __src_struct: &[u8] =
        unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 26 as usize) };
    __dst[8..__fixed_len].copy_from_slice(__src_struct);

    // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_set_state_ipv6(
    __dest: *mut u8,
    __dest_len: u32,
    __tstamp: u64,
    dest: *const u8,
    src: *const u8,
    dport: u16,
    sport: u16,
    sk: u64,
    tx_rx: u32,
) {
    assert!(!__dest.is_null(), "dest must not be null");

    // Compute encoded length: fixed struct size + dynamic payload
    let __consumed: u32 = 50 as u32;

    let __total_len = (8_u32).saturating_add(__consumed) as usize;
    assert!(
        __total_len == __dest_len as usize,
        "dest len must exactly match computed encoded len"
    );

    // Prepare destination and input slices up front
    let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };
    let __sl_dest: &[u8] = unsafe { slice::from_raw_parts(dest, 16) };
    let __sl_src: &[u8] = unsafe { slice::from_raw_parts(src, 16) };

    // Build fixed header as a stack struct using an initializer expression
    let __wire: jb_agent_internal__set_state_ipv6 = jb_agent_internal__set_state_ipv6 {
        _rpc_id: 340 as u16,
        dport,
        tx_rx,
        sk,
        sport,
        dest: __sl_dest.try_into().unwrap(),
        src: __sl_src.try_into().unwrap(),
    };

    // Copy timestamp and packed header (without struct tail padding)
    let __fixed_len = 8usize + 50 as usize;
    __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
    let __src_struct: &[u8] =
        unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 50 as usize) };
    __dst[8..__fixed_len].copy_from_slice(__src_struct);

    // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_rtt_estimator(
    __dest: *mut u8,
    __dest_len: u32,
    __tstamp: u64,
    srtt: u32,
    snd_cwnd: u32,
    bytes_acked: u64,
    ca_state: u8,
    sk: u64,
    packets_in_flight: u32,
    packets_delivered: u32,
    packets_retrans: u32,
    rcv_holes: u32,
    bytes_received: u64,
    rcv_delivered: u32,
    rcv_rtt: u32,
) {
    assert!(!__dest.is_null(), "dest must not be null");

    // Compute encoded length: fixed struct size + dynamic payload
    let __consumed: u32 = 60 as u32;

    let __total_len = (8_u32).saturating_add(__consumed) as usize;
    assert!(
        __total_len == __dest_len as usize,
        "dest len must exactly match computed encoded len"
    );

    // Prepare destination and input slices up front
    let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };

    // Build fixed header as a stack struct using an initializer expression
    let __wire: jb_agent_internal__rtt_estimator = jb_agent_internal__rtt_estimator {
        _rpc_id: 361 as u16,
        ca_state,
        srtt,
        bytes_acked,
        sk,
        bytes_received,
        snd_cwnd,
        packets_in_flight,
        packets_delivered,
        packets_retrans,
        rcv_holes,
        rcv_delivered,
        rcv_rtt,
    };

    // Copy timestamp and packed header (without struct tail padding)
    let __fixed_len = 8usize + 60 as usize;
    __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
    let __src_struct: &[u8] =
        unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 60 as usize) };
    __dst[8..__fixed_len].copy_from_slice(__src_struct);

    // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_close_sock_info(
    __dest: *mut u8,
    __dest_len: u32,
    __tstamp: u64,
    sk: u64,
) {
    assert!(!__dest.is_null(), "dest must not be null");

    // Compute encoded length: fixed struct size + dynamic payload
    let __consumed: u32 = 16 as u32;

    let __total_len = (8_u32).saturating_add(__consumed) as usize;
    assert!(
        __total_len == __dest_len as usize,
        "dest len must exactly match computed encoded len"
    );

    // Prepare destination and input slices up front
    let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };

    // Build fixed header as a stack struct using an initializer expression
    let __wire: jb_agent_internal__close_sock_info = jb_agent_internal__close_sock_info {
        _rpc_id: 362 as u16,
        sk,
    };

    // Copy timestamp and packed header (without struct tail padding)
    let __fixed_len = 8usize + 16 as usize;
    __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
    let __src_struct: &[u8] =
        unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 16 as usize) };
    __dst[8..__fixed_len].copy_from_slice(__src_struct);

    // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_kill_css(
    __dest: *mut u8,
    __dest_len: u32,
    __tstamp: u64,
    cgroup: u64,
    cgroup_parent: u64,
    name: *const u8,
) {
    assert!(!__dest.is_null(), "dest must not be null");

    // Compute encoded length: fixed struct size + dynamic payload
    let __consumed: u32 = 280 as u32;

    let __total_len = (8_u32).saturating_add(__consumed) as usize;
    assert!(
        __total_len == __dest_len as usize,
        "dest len must exactly match computed encoded len"
    );

    // Prepare destination and input slices up front
    let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };
    let __sl_name: &[u8] = unsafe { slice::from_raw_parts(name, 256) };

    // Build fixed header as a stack struct using an initializer expression
    let __wire: jb_agent_internal__kill_css = jb_agent_internal__kill_css {
        _rpc_id: 363 as u16,
        name: __sl_name.try_into().unwrap(),
        cgroup,
        cgroup_parent,
    };

    // Copy timestamp and packed header (without struct tail padding)
    let __fixed_len = 8usize + 280 as usize;
    __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
    let __src_struct: &[u8] =
        unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 280 as usize) };
    __dst[8..__fixed_len].copy_from_slice(__src_struct);

    // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_css_populate_dir(
    __dest: *mut u8,
    __dest_len: u32,
    __tstamp: u64,
    cgroup: u64,
    cgroup_parent: u64,
    name: *const u8,
) {
    assert!(!__dest.is_null(), "dest must not be null");

    // Compute encoded length: fixed struct size + dynamic payload
    let __consumed: u32 = 280 as u32;

    let __total_len = (8_u32).saturating_add(__consumed) as usize;
    assert!(
        __total_len == __dest_len as usize,
        "dest len must exactly match computed encoded len"
    );

    // Prepare destination and input slices up front
    let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };
    let __sl_name: &[u8] = unsafe { slice::from_raw_parts(name, 256) };

    // Build fixed header as a stack struct using an initializer expression
    let __wire: jb_agent_internal__css_populate_dir = jb_agent_internal__css_populate_dir {
        _rpc_id: 364 as u16,
        name: __sl_name.try_into().unwrap(),
        cgroup,
        cgroup_parent,
    };

    // Copy timestamp and packed header (without struct tail padding)
    let __fixed_len = 8usize + 280 as usize;
    __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
    let __src_struct: &[u8] =
        unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 280 as usize) };
    __dst[8..__fixed_len].copy_from_slice(__src_struct);

    // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_existing_cgroup_probe(
    __dest: *mut u8,
    __dest_len: u32,
    __tstamp: u64,
    cgroup: u64,
    cgroup_parent: u64,
    name: *const u8,
) {
    assert!(!__dest.is_null(), "dest must not be null");

    // Compute encoded length: fixed struct size + dynamic payload
    let __consumed: u32 = 280 as u32;

    let __total_len = (8_u32).saturating_add(__consumed) as usize;
    assert!(
        __total_len == __dest_len as usize,
        "dest len must exactly match computed encoded len"
    );

    // Prepare destination and input slices up front
    let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };
    let __sl_name: &[u8] = unsafe { slice::from_raw_parts(name, 256) };

    // Build fixed header as a stack struct using an initializer expression
    let __wire: jb_agent_internal__existing_cgroup_probe =
        jb_agent_internal__existing_cgroup_probe {
            _rpc_id: 365 as u16,
            name: __sl_name.try_into().unwrap(),
            cgroup,
            cgroup_parent,
        };

    // Copy timestamp and packed header (without struct tail padding)
    let __fixed_len = 8usize + 280 as usize;
    __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
    let __src_struct: &[u8] =
        unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 280 as usize) };
    __dst[8..__fixed_len].copy_from_slice(__src_struct);

    // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_cgroup_attach_task(
    __dest: *mut u8,
    __dest_len: u32,
    __tstamp: u64,
    cgroup: u64,
    pid: u32,
    comm: *const u8,
) {
    assert!(!__dest.is_null(), "dest must not be null");

    // Compute encoded length: fixed struct size + dynamic payload
    let __consumed: u32 = 32 as u32;

    let __total_len = (8_u32).saturating_add(__consumed) as usize;
    assert!(
        __total_len == __dest_len as usize,
        "dest len must exactly match computed encoded len"
    );

    // Prepare destination and input slices up front
    let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };
    let __sl_comm: &[u8] = unsafe { slice::from_raw_parts(comm, 16) };

    // Build fixed header as a stack struct using an initializer expression
    let __wire: jb_agent_internal__cgroup_attach_task = jb_agent_internal__cgroup_attach_task {
        _rpc_id: 366 as u16,
        comm: __sl_comm.try_into().unwrap(),
        pid,
        cgroup,
    };

    // Copy timestamp and packed header (without struct tail padding)
    let __fixed_len = 8usize + 32 as usize;
    __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
    let __src_struct: &[u8] =
        unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 32 as usize) };
    __dst[8..__fixed_len].copy_from_slice(__src_struct);

    // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_nf_conntrack_alter_reply(
    __dest: *mut u8,
    __dest_len: u32,
    __tstamp: u64,
    ct: u64,
    src_ip: u32,
    src_port: u16,
    dst_ip: u32,
    dst_port: u16,
    proto: u8,
    nat_src_ip: u32,
    nat_src_port: u16,
    nat_dst_ip: u32,
    nat_dst_port: u16,
    nat_proto: u8,
) {
    assert!(!__dest.is_null(), "dest must not be null");

    // Compute encoded length: fixed struct size + dynamic payload
    let __consumed: u32 = 36 as u32;

    let __total_len = (8_u32).saturating_add(__consumed) as usize;
    assert!(
        __total_len == __dest_len as usize,
        "dest len must exactly match computed encoded len"
    );

    // Prepare destination and input slices up front
    let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };

    // Build fixed header as a stack struct using an initializer expression
    let __wire: jb_agent_internal__nf_conntrack_alter_reply =
        jb_agent_internal__nf_conntrack_alter_reply {
            _rpc_id: 367 as u16,
            src_port,
            src_ip,
            ct,
            dst_ip,
            nat_src_ip,
            nat_dst_ip,
            dst_port,
            nat_src_port,
            nat_dst_port,
            proto,
            nat_proto,
        };

    // Copy timestamp and packed header (without struct tail padding)
    let __fixed_len = 8usize + 36 as usize;
    __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
    let __src_struct: &[u8] =
        unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 36 as usize) };
    __dst[8..__fixed_len].copy_from_slice(__src_struct);

    // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_nf_nat_cleanup_conntrack(
    __dest: *mut u8,
    __dest_len: u32,
    __tstamp: u64,
    ct: u64,
    src_ip: u32,
    src_port: u16,
    dst_ip: u32,
    dst_port: u16,
    proto: u8,
) {
    assert!(!__dest.is_null(), "dest must not be null");

    // Compute encoded length: fixed struct size + dynamic payload
    let __consumed: u32 = 23 as u32;

    let __total_len = (8_u32).saturating_add(__consumed) as usize;
    assert!(
        __total_len == __dest_len as usize,
        "dest len must exactly match computed encoded len"
    );

    // Prepare destination and input slices up front
    let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };

    // Build fixed header as a stack struct using an initializer expression
    let __wire: jb_agent_internal__nf_nat_cleanup_conntrack =
        jb_agent_internal__nf_nat_cleanup_conntrack {
            _rpc_id: 368 as u16,
            src_port,
            src_ip,
            ct,
            dst_ip,
            dst_port,
            proto,
        };

    // Copy timestamp and packed header (without struct tail padding)
    let __fixed_len = 8usize + 23 as usize;
    __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
    let __src_struct: &[u8] =
        unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 23 as usize) };
    __dst[8..__fixed_len].copy_from_slice(__src_struct);

    // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_existing_conntrack_tuple(
    __dest: *mut u8,
    __dest_len: u32,
    __tstamp: u64,
    ct: u64,
    src_ip: u32,
    src_port: u16,
    dst_ip: u32,
    dst_port: u16,
    proto: u8,
    dir: u8,
) {
    assert!(!__dest.is_null(), "dest must not be null");

    // Compute encoded length: fixed struct size + dynamic payload
    let __consumed: u32 = 24 as u32;

    let __total_len = (8_u32).saturating_add(__consumed) as usize;
    assert!(
        __total_len == __dest_len as usize,
        "dest len must exactly match computed encoded len"
    );

    // Prepare destination and input slices up front
    let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };

    // Build fixed header as a stack struct using an initializer expression
    let __wire: jb_agent_internal__existing_conntrack_tuple =
        jb_agent_internal__existing_conntrack_tuple {
            _rpc_id: 369 as u16,
            src_port,
            src_ip,
            ct,
            dst_ip,
            dst_port,
            proto,
            dir,
        };

    // Copy timestamp and packed header (without struct tail padding)
    let __fixed_len = 8usize + 24 as usize;
    __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
    let __src_struct: &[u8] =
        unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 24 as usize) };
    __dst[8..__fixed_len].copy_from_slice(__src_struct);

    // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_tcp_syn_timeout(
    __dest: *mut u8,
    __dest_len: u32,
    __tstamp: u64,
    sk: u64,
) {
    assert!(!__dest.is_null(), "dest must not be null");

    // Compute encoded length: fixed struct size + dynamic payload
    let __consumed: u32 = 16 as u32;

    let __total_len = (8_u32).saturating_add(__consumed) as usize;
    assert!(
        __total_len == __dest_len as usize,
        "dest len must exactly match computed encoded len"
    );

    // Prepare destination and input slices up front
    let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };

    // Build fixed header as a stack struct using an initializer expression
    let __wire: jb_agent_internal__tcp_syn_timeout = jb_agent_internal__tcp_syn_timeout {
        _rpc_id: 370 as u16,
        sk,
    };

    // Copy timestamp and packed header (without struct tail padding)
    let __fixed_len = 8usize + 16 as usize;
    __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
    let __src_struct: &[u8] =
        unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 16 as usize) };
    __dst[8..__fixed_len].copy_from_slice(__src_struct);

    // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_http_response(
    __dest: *mut u8,
    __dest_len: u32,
    __tstamp: u64,
    sk: u64,
    pid: u32,
    code: u16,
    latency_ns: u64,
    client_server: u8,
) {
    assert!(!__dest.is_null(), "dest must not be null");

    // Compute encoded length: fixed struct size + dynamic payload
    let __consumed: u32 = 25 as u32;

    let __total_len = (8_u32).saturating_add(__consumed) as usize;
    assert!(
        __total_len == __dest_len as usize,
        "dest len must exactly match computed encoded len"
    );

    // Prepare destination and input slices up front
    let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };

    // Build fixed header as a stack struct using an initializer expression
    let __wire: jb_agent_internal__http_response = jb_agent_internal__http_response {
        _rpc_id: 372 as u16,
        code,
        pid,
        sk,
        latency_ns,
        client_server,
    };

    // Copy timestamp and packed header (without struct tail padding)
    let __fixed_len = 8usize + 25 as usize;
    __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
    let __src_struct: &[u8] =
        unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 25 as usize) };
    __dst[8..__fixed_len].copy_from_slice(__src_struct);

    // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_bpf_log(
    __dest: *mut u8,
    __dest_len: u32,
    __tstamp: u64,
    filelineid: u64,
    code: u64,
    arg0: u64,
    arg1: u64,
    arg2: u64,
) {
    assert!(!__dest.is_null(), "dest must not be null");

    // Compute encoded length: fixed struct size + dynamic payload
    let __consumed: u32 = 48 as u32;

    let __total_len = (8_u32).saturating_add(__consumed) as usize;
    assert!(
        __total_len == __dest_len as usize,
        "dest len must exactly match computed encoded len"
    );

    // Prepare destination and input slices up front
    let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };

    // Build fixed header as a stack struct using an initializer expression
    let __wire: jb_agent_internal__bpf_log = jb_agent_internal__bpf_log {
        _rpc_id: 373 as u16,
        filelineid,
        code,
        arg0,
        arg1,
        arg2,
    };

    // Copy timestamp and packed header (without struct tail padding)
    let __fixed_len = 8usize + 48 as usize;
    __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
    let __src_struct: &[u8] =
        unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 48 as usize) };
    __dst[8..__fixed_len].copy_from_slice(__src_struct);

    // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_stack_trace(
    __dest: *mut u8,
    __dest_len: u32,
    __tstamp: u64,
    kernel_stack_id: i32,
    user_stack_id: i32,
    tgid: u32,
    comm: *const u8,
) {
    assert!(!__dest.is_null(), "dest must not be null");

    // Compute encoded length: fixed struct size + dynamic payload
    let __consumed: u32 = 32 as u32;

    let __total_len = (8_u32).saturating_add(__consumed) as usize;
    assert!(
        __total_len == __dest_len as usize,
        "dest len must exactly match computed encoded len"
    );

    // Prepare destination and input slices up front
    let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };
    let __sl_comm: &[u8] = unsafe { slice::from_raw_parts(comm, 16) };

    // Build fixed header as a stack struct using an initializer expression
    let __wire: jb_agent_internal__stack_trace = jb_agent_internal__stack_trace {
        _rpc_id: 374 as u16,
        comm: __sl_comm.try_into().unwrap(),
        kernel_stack_id,
        user_stack_id,
        tgid,
    };

    // Copy timestamp and packed header (without struct tail padding)
    let __fixed_len = 8usize + 32 as usize;
    __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
    let __src_struct: &[u8] =
        unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 32 as usize) };
    __dst[8..__fixed_len].copy_from_slice(__src_struct);

    // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_tcp_data(
    __dest: *mut u8,
    __dest_len: u32,
    __tstamp: u64,
    sk: u64,
    pid: u32,
    length: u32,
    offset: u64,
    stream_type: u8,
    client_server: u8,
) {
    assert!(!__dest.is_null(), "dest must not be null");

    // Compute encoded length: fixed struct size + dynamic payload
    let __consumed: u32 = 28 as u32;

    let __total_len = (8_u32).saturating_add(__consumed) as usize;
    assert!(
        __total_len == __dest_len as usize,
        "dest len must exactly match computed encoded len"
    );

    // Prepare destination and input slices up front
    let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };

    // Build fixed header as a stack struct using an initializer expression
    let __wire: jb_agent_internal__tcp_data = jb_agent_internal__tcp_data {
        _rpc_id: 375 as u16,
        stream_type,
        client_server,
        pid,
        sk,
        offset,
        length,
    };

    // Copy timestamp and packed header (without struct tail padding)
    let __fixed_len = 8usize + 28 as usize;
    __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
    let __src_struct: &[u8] =
        unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 28 as usize) };
    __dst[8..__fixed_len].copy_from_slice(__src_struct);

    // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_pid_exit(
    __dest: *mut u8,
    __dest_len: u32,
    __tstamp: u64,
    tgid: u64,
    pid: u32,
    exit_code: i32,
) {
    assert!(!__dest.is_null(), "dest must not be null");

    // Compute encoded length: fixed struct size + dynamic payload
    let __consumed: u32 = 20 as u32;

    let __total_len = (8_u32).saturating_add(__consumed) as usize;
    assert!(
        __total_len == __dest_len as usize,
        "dest len must exactly match computed encoded len"
    );

    // Prepare destination and input slices up front
    let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };

    // Build fixed header as a stack struct using an initializer expression
    let __wire: jb_agent_internal__pid_exit = jb_agent_internal__pid_exit {
        _rpc_id: 377 as u16,
        pid,
        tgid,
        exit_code,
    };

    // Copy timestamp and packed header (without struct tail padding)
    let __fixed_len = 8usize + 20 as usize;
    __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
    let __src_struct: &[u8] =
        unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 20 as usize) };
    __dst[8..__fixed_len].copy_from_slice(__src_struct);

    // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_report_debug_event(
    __dest: *mut u8,
    __dest_len: u32,
    __tstamp: u64,
    event: u16,
    arg1: u64,
    arg2: u64,
    arg3: u64,
    arg4: u64,
) {
    assert!(!__dest.is_null(), "dest must not be null");

    // Compute encoded length: fixed struct size + dynamic payload
    let __consumed: u32 = 40 as u32;

    let __total_len = (8_u32).saturating_add(__consumed) as usize;
    assert!(
        __total_len == __dest_len as usize,
        "dest len must exactly match computed encoded len"
    );

    // Prepare destination and input slices up front
    let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };

    // Build fixed header as a stack struct using an initializer expression
    let __wire: jb_agent_internal__report_debug_event = jb_agent_internal__report_debug_event {
        _rpc_id: 378 as u16,
        event,
        arg1,
        arg2,
        arg3,
        arg4,
    };

    // Copy timestamp and packed header (without struct tail padding)
    let __fixed_len = 8usize + 40 as usize;
    __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
    let __src_struct: &[u8] =
        unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 40 as usize) };
    __dst[8..__fixed_len].copy_from_slice(__src_struct);

    // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_tcp_reset(
    __dest: *mut u8,
    __dest_len: u32,
    __tstamp: u64,
    sk: u64,
    is_rx: u8,
) {
    assert!(!__dest.is_null(), "dest must not be null");

    // Compute encoded length: fixed struct size + dynamic payload
    let __consumed: u32 = 16 as u32;

    let __total_len = (8_u32).saturating_add(__consumed) as usize;
    assert!(
        __total_len == __dest_len as usize,
        "dest len must exactly match computed encoded len"
    );

    // Prepare destination and input slices up front
    let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };

    // Build fixed header as a stack struct using an initializer expression
    let __wire: jb_agent_internal__tcp_reset = jb_agent_internal__tcp_reset {
        _rpc_id: 379 as u16,
        is_rx,
        sk,
    };

    // Copy timestamp and packed header (without struct tail padding)
    let __fixed_len = 8usize + 16 as usize;
    __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
    let __src_struct: &[u8] =
        unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 16 as usize) };
    __dst[8..__fixed_len].copy_from_slice(__src_struct);

    // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_pulse(
    __dest: *mut u8,
    __dest_len: u32,
    __tstamp: u64,
) {
    assert!(!__dest.is_null(), "dest must not be null");

    // Compute encoded length: fixed struct size + dynamic payload
    let __consumed: u32 = 2 as u32;

    let __total_len = (8_u32).saturating_add(__consumed) as usize;
    assert!(
        __total_len == __dest_len as usize,
        "dest len must exactly match computed encoded len"
    );

    // Prepare destination and input slices up front
    let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };

    // Build fixed header as a stack struct using an initializer expression
    let __wire: jb_agent_internal__pulse = jb_agent_internal__pulse {
        _rpc_id: 65535 as u16,
    };

    // Copy timestamp and packed header (without struct tail padding)
    let __fixed_len = 8usize + 2 as usize;
    __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
    let __src_struct: &[u8] =
        unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 2 as usize) };
    __dst[8..__fixed_len].copy_from_slice(__src_struct);

    // Append dynamic payloads sequentially
}
