// Auto-generated by Render: Rust FFI for ebpf_net::agent_internal
#[allow(non_camel_case_types)]
#[allow(non_snake_case)]
#[allow(unused_variables)]

#[allow(unused_imports)]
use crate::JbBlob;

use crate::wire_messages::*;

use core::slice;

#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_dns_packet(
  __dest: *mut u8,
  __dest_len: u32,
  __tstamp: u64,
  sk: u64,
  pkt: JbBlob,
  total_len: u16,
  is_rx: u8
) {
  assert!(!__dest.is_null(), "dest must not be null");

  // Compute encoded length: fixed struct size + dynamic payload
  let mut __consumed: u32 = 16 as u32;
  __consumed = __consumed.saturating_add(pkt.len as u32);
  assert!(__consumed <= 0xffff, "encoded len must fit in u16");

  let __total_len = (8_u32).saturating_add(__consumed) as usize;
  assert!(
    __total_len == __dest_len as usize,
    "dest len must exactly match computed encoded len"
  );

  // Prepare destination and input slices up front
  let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };
  let __sl_pkt: &[u8] = unsafe { slice::from_raw_parts(pkt.buf as *const u8, pkt.len as usize) };

  // Build fixed header as a stack struct using an initializer expression
  let __wire: jb_agent_internal__dns_packet = jb_agent_internal__dns_packet {
    _rpc_id: 331 as u16,
    _len: __consumed as u16,
    total_len,
    is_rx,
    sk
  };

  // Copy timestamp and packed header (without struct tail padding)
  let __fixed_len = 8usize + 16 as usize;
  __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
  let __src_struct: &[u8] = unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 16 as usize) };
  __dst[8..__fixed_len].copy_from_slice(__src_struct);

  // Append dynamic payloads sequentially
  let mut __off = __fixed_len;
  if !__sl_pkt.is_empty() {
    let __len = __sl_pkt.len();
    let __dst_seg = &mut __dst[__off .. __off + __len];
    __dst_seg.copy_from_slice(__sl_pkt);
    __off += __len;
  }
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_reset_tcp_counters(
  __dest: *mut u8,
  __dest_len: u32,
  __tstamp: u64,
  sk: u64,
  bytes_acked: u64,
  packets_delivered: u32,
  packets_retrans: u32,
  bytes_received: u64,
  pid: u32
) {
  assert!(!__dest.is_null(), "dest must not be null");

  // Compute encoded length: fixed struct size + dynamic payload
  let __consumed: u32 = 40 as u32;

  let __total_len = (8_u32).saturating_add(__consumed) as usize;
  assert!(
    __total_len == __dest_len as usize,
    "dest len must exactly match computed encoded len"
  );

  // Prepare destination and input slices up front
  let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };

  // Build fixed header as a stack struct using an initializer expression
  let __wire: jb_agent_internal__reset_tcp_counters = jb_agent_internal__reset_tcp_counters {
    _rpc_id: 332 as u16,
    packets_delivered,
    sk,
    bytes_acked,
    bytes_received,
    packets_retrans,
    pid
  };

  // Copy timestamp and packed header (without struct tail padding)
  let __fixed_len = 8usize + 40 as usize;
  __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
  let __src_struct: &[u8] = unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 40 as usize) };
  __dst[8..__fixed_len].copy_from_slice(__src_struct);

  // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_new_sock_created(
  __dest: *mut u8,
  __dest_len: u32,
  __tstamp: u64,
  pid: u32,
  sk: u64
) {
  assert!(!__dest.is_null(), "dest must not be null");

  // Compute encoded length: fixed struct size + dynamic payload
  let __consumed: u32 = 16 as u32;

  let __total_len = (8_u32).saturating_add(__consumed) as usize;
  assert!(
    __total_len == __dest_len as usize,
    "dest len must exactly match computed encoded len"
  );

  // Prepare destination and input slices up front
  let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };

  // Build fixed header as a stack struct using an initializer expression
  let __wire: jb_agent_internal__new_sock_created = jb_agent_internal__new_sock_created {
    _rpc_id: 333 as u16,
    pid,
    sk
  };

  // Copy timestamp and packed header (without struct tail padding)
  let __fixed_len = 8usize + 16 as usize;
  __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
  let __src_struct: &[u8] = unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 16 as usize) };
  __dst[8..__fixed_len].copy_from_slice(__src_struct);

  // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_udp_new_socket(
  __dest: *mut u8,
  __dest_len: u32,
  __tstamp: u64,
  pid: u32,
  sk: u64,
  laddr: *const u8,
  lport: u16
) {
  assert!(!__dest.is_null(), "dest must not be null");

  // Compute encoded length: fixed struct size + dynamic payload
  let __consumed: u32 = 32 as u32;

  let __total_len = (8_u32).saturating_add(__consumed) as usize;
  assert!(
    __total_len == __dest_len as usize,
    "dest len must exactly match computed encoded len"
  );

  // Prepare destination and input slices up front
  let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };
  let __sl_laddr: &[u8] = unsafe { slice::from_raw_parts(laddr, 16) };

  // Build fixed header as a stack struct using an initializer expression
  let __wire: jb_agent_internal__udp_new_socket = jb_agent_internal__udp_new_socket {
    _rpc_id: 334 as u16,
    lport,
    pid,
    sk,
    laddr: __sl_laddr.try_into().unwrap()
  };

  // Copy timestamp and packed header (without struct tail padding)
  let __fixed_len = 8usize + 32 as usize;
  __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
  let __src_struct: &[u8] = unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 32 as usize) };
  __dst[8..__fixed_len].copy_from_slice(__src_struct);

  // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_udp_destroy_socket(
  __dest: *mut u8,
  __dest_len: u32,
  __tstamp: u64,
  sk: u64
) {
  assert!(!__dest.is_null(), "dest must not be null");

  // Compute encoded length: fixed struct size + dynamic payload
  let __consumed: u32 = 16 as u32;

  let __total_len = (8_u32).saturating_add(__consumed) as usize;
  assert!(
    __total_len == __dest_len as usize,
    "dest len must exactly match computed encoded len"
  );

  // Prepare destination and input slices up front
  let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };

  // Build fixed header as a stack struct using an initializer expression
  let __wire: jb_agent_internal__udp_destroy_socket = jb_agent_internal__udp_destroy_socket {
    _rpc_id: 335 as u16,
    sk
  };

  // Copy timestamp and packed header (without struct tail padding)
  let __fixed_len = 8usize + 16 as usize;
  __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
  let __src_struct: &[u8] = unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 16 as usize) };
  __dst[8..__fixed_len].copy_from_slice(__src_struct);

  // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_udp_stats(
  __dest: *mut u8,
  __dest_len: u32,
  __tstamp: u64,
  sk: u64,
  raddr: *const u8,
  packets: u32,
  bytes: u32,
  changed_af: u8,
  rport: u16,
  is_rx: u8,
  laddr: *const u8,
  lport: u16,
  drops: u32
) {
  assert!(!__dest.is_null(), "dest must not be null");

  // Compute encoded length: fixed struct size + dynamic payload
  let __consumed: u32 = 60 as u32;

  let __total_len = (8_u32).saturating_add(__consumed) as usize;
  assert!(
    __total_len == __dest_len as usize,
    "dest len must exactly match computed encoded len"
  );

  // Prepare destination and input slices up front
  let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };
  let __sl_raddr: &[u8] = unsafe { slice::from_raw_parts(raddr, 16) };
  let __sl_laddr: &[u8] = unsafe { slice::from_raw_parts(laddr, 16) };

  // Build fixed header as a stack struct using an initializer expression
  let __wire: jb_agent_internal__udp_stats = jb_agent_internal__udp_stats {
    _rpc_id: 336 as u16,
    rport,
    packets,
    sk,
    bytes,
    drops,
    lport,
    raddr: __sl_raddr.try_into().unwrap(),
    changed_af,
    is_rx,
    laddr: __sl_laddr.try_into().unwrap()
  };

  // Copy timestamp and packed header (without struct tail padding)
  let __fixed_len = 8usize + 60 as usize;
  __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
  let __src_struct: &[u8] = unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 60 as usize) };
  __dst[8..__fixed_len].copy_from_slice(__src_struct);

  // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_pid_info(
  __dest: *mut u8,
  __dest_len: u32,
  __tstamp: u64,
  pid: u32,
  comm: *const u8,
  cgroup: u64,
  parent_pid: i32
) {
  assert!(!__dest.is_null(), "dest must not be null");

  // Compute encoded length: fixed struct size + dynamic payload
  let __consumed: u32 = 36 as u32;

  let __total_len = (8_u32).saturating_add(__consumed) as usize;
  assert!(
    __total_len == __dest_len as usize,
    "dest len must exactly match computed encoded len"
  );

  // Prepare destination and input slices up front
  let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };
  let __sl_comm: &[u8] = unsafe { slice::from_raw_parts(comm, 16) };

  // Build fixed header as a stack struct using an initializer expression
  let __wire: jb_agent_internal__pid_info = jb_agent_internal__pid_info {
    _rpc_id: 337 as u16,
    comm: __sl_comm.try_into().unwrap(),
    pid,
    cgroup,
    parent_pid
  };

  // Copy timestamp and packed header (without struct tail padding)
  let __fixed_len = 8usize + 36 as usize;
  __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
  let __src_struct: &[u8] = unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 36 as usize) };
  __dst[8..__fixed_len].copy_from_slice(__src_struct);

  // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_pid_close(
  __dest: *mut u8,
  __dest_len: u32,
  __tstamp: u64,
  pid: u32,
  comm: *const u8
) {
  assert!(!__dest.is_null(), "dest must not be null");

  // Compute encoded length: fixed struct size + dynamic payload
  let __consumed: u32 = 24 as u32;

  let __total_len = (8_u32).saturating_add(__consumed) as usize;
  assert!(
    __total_len == __dest_len as usize,
    "dest len must exactly match computed encoded len"
  );

  // Prepare destination and input slices up front
  let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };
  let __sl_comm: &[u8] = unsafe { slice::from_raw_parts(comm, 16) };

  // Build fixed header as a stack struct using an initializer expression
  let __wire: jb_agent_internal__pid_close = jb_agent_internal__pid_close {
    _rpc_id: 338 as u16,
    comm: __sl_comm.try_into().unwrap(),
    pid
  };

  // Copy timestamp and packed header (without struct tail padding)
  let __fixed_len = 8usize + 24 as usize;
  __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
  let __src_struct: &[u8] = unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 24 as usize) };
  __dst[8..__fixed_len].copy_from_slice(__src_struct);

  // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_pid_set_comm(
  __dest: *mut u8,
  __dest_len: u32,
  __tstamp: u64,
  pid: u32,
  comm: *const u8
) {
  assert!(!__dest.is_null(), "dest must not be null");

  // Compute encoded length: fixed struct size + dynamic payload
  let __consumed: u32 = 24 as u32;

  let __total_len = (8_u32).saturating_add(__consumed) as usize;
  assert!(
    __total_len == __dest_len as usize,
    "dest len must exactly match computed encoded len"
  );

  // Prepare destination and input slices up front
  let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };
  let __sl_comm: &[u8] = unsafe { slice::from_raw_parts(comm, 16) };

  // Build fixed header as a stack struct using an initializer expression
  let __wire: jb_agent_internal__pid_set_comm = jb_agent_internal__pid_set_comm {
    _rpc_id: 371 as u16,
    comm: __sl_comm.try_into().unwrap(),
    pid
  };

  // Copy timestamp and packed header (without struct tail padding)
  let __fixed_len = 8usize + 24 as usize;
  __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
  let __src_struct: &[u8] = unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 24 as usize) };
  __dst[8..__fixed_len].copy_from_slice(__src_struct);

  // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_set_state_ipv4(
  __dest: *mut u8,
  __dest_len: u32,
  __tstamp: u64,
  dest: u32,
  src: u32,
  dport: u16,
  sport: u16,
  sk: u64,
  tx_rx: u32
) {
  assert!(!__dest.is_null(), "dest must not be null");

  // Compute encoded length: fixed struct size + dynamic payload
  let __consumed: u32 = 26 as u32;

  let __total_len = (8_u32).saturating_add(__consumed) as usize;
  assert!(
    __total_len == __dest_len as usize,
    "dest len must exactly match computed encoded len"
  );

  // Prepare destination and input slices up front
  let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };

  // Build fixed header as a stack struct using an initializer expression
  let __wire: jb_agent_internal__set_state_ipv4 = jb_agent_internal__set_state_ipv4 {
    _rpc_id: 339 as u16,
    dport,
    dest,
    sk,
    src,
    tx_rx,
    sport
  };

  // Copy timestamp and packed header (without struct tail padding)
  let __fixed_len = 8usize + 26 as usize;
  __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
  let __src_struct: &[u8] = unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 26 as usize) };
  __dst[8..__fixed_len].copy_from_slice(__src_struct);

  // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_set_state_ipv6(
  __dest: *mut u8,
  __dest_len: u32,
  __tstamp: u64,
  dest: *const u8,
  src: *const u8,
  dport: u16,
  sport: u16,
  sk: u64,
  tx_rx: u32
) {
  assert!(!__dest.is_null(), "dest must not be null");

  // Compute encoded length: fixed struct size + dynamic payload
  let __consumed: u32 = 50 as u32;

  let __total_len = (8_u32).saturating_add(__consumed) as usize;
  assert!(
    __total_len == __dest_len as usize,
    "dest len must exactly match computed encoded len"
  );

  // Prepare destination and input slices up front
  let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };
  let __sl_dest: &[u8] = unsafe { slice::from_raw_parts(dest, 16) };
  let __sl_src: &[u8] = unsafe { slice::from_raw_parts(src, 16) };

  // Build fixed header as a stack struct using an initializer expression
  let __wire: jb_agent_internal__set_state_ipv6 = jb_agent_internal__set_state_ipv6 {
    _rpc_id: 340 as u16,
    dport,
    tx_rx,
    sk,
    sport,
    dest: __sl_dest.try_into().unwrap(),
    src: __sl_src.try_into().unwrap()
  };

  // Copy timestamp and packed header (without struct tail padding)
  let __fixed_len = 8usize + 50 as usize;
  __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
  let __src_struct: &[u8] = unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 50 as usize) };
  __dst[8..__fixed_len].copy_from_slice(__src_struct);

  // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_rtt_estimator(
  __dest: *mut u8,
  __dest_len: u32,
  __tstamp: u64,
  srtt: u32,
  snd_cwnd: u32,
  bytes_acked: u64,
  ca_state: u8,
  sk: u64,
  packets_in_flight: u32,
  packets_delivered: u32,
  packets_retrans: u32,
  rcv_holes: u32,
  bytes_received: u64,
  rcv_delivered: u32,
  rcv_rtt: u32
) {
  assert!(!__dest.is_null(), "dest must not be null");

  // Compute encoded length: fixed struct size + dynamic payload
  let __consumed: u32 = 60 as u32;

  let __total_len = (8_u32).saturating_add(__consumed) as usize;
  assert!(
    __total_len == __dest_len as usize,
    "dest len must exactly match computed encoded len"
  );

  // Prepare destination and input slices up front
  let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };

  // Build fixed header as a stack struct using an initializer expression
  let __wire: jb_agent_internal__rtt_estimator = jb_agent_internal__rtt_estimator {
    _rpc_id: 361 as u16,
    ca_state,
    srtt,
    bytes_acked,
    sk,
    bytes_received,
    snd_cwnd,
    packets_in_flight,
    packets_delivered,
    packets_retrans,
    rcv_holes,
    rcv_delivered,
    rcv_rtt
  };

  // Copy timestamp and packed header (without struct tail padding)
  let __fixed_len = 8usize + 60 as usize;
  __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
  let __src_struct: &[u8] = unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 60 as usize) };
  __dst[8..__fixed_len].copy_from_slice(__src_struct);

  // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_close_sock_info(
  __dest: *mut u8,
  __dest_len: u32,
  __tstamp: u64,
  sk: u64
) {
  assert!(!__dest.is_null(), "dest must not be null");

  // Compute encoded length: fixed struct size + dynamic payload
  let __consumed: u32 = 16 as u32;

  let __total_len = (8_u32).saturating_add(__consumed) as usize;
  assert!(
    __total_len == __dest_len as usize,
    "dest len must exactly match computed encoded len"
  );

  // Prepare destination and input slices up front
  let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };

  // Build fixed header as a stack struct using an initializer expression
  let __wire: jb_agent_internal__close_sock_info = jb_agent_internal__close_sock_info {
    _rpc_id: 362 as u16,
    sk
  };

  // Copy timestamp and packed header (without struct tail padding)
  let __fixed_len = 8usize + 16 as usize;
  __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
  let __src_struct: &[u8] = unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 16 as usize) };
  __dst[8..__fixed_len].copy_from_slice(__src_struct);

  // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_kill_css(
  __dest: *mut u8,
  __dest_len: u32,
  __tstamp: u64,
  cgroup: u64,
  cgroup_parent: u64,
  name: *const u8
) {
  assert!(!__dest.is_null(), "dest must not be null");

  // Compute encoded length: fixed struct size + dynamic payload
  let __consumed: u32 = 280 as u32;

  let __total_len = (8_u32).saturating_add(__consumed) as usize;
  assert!(
    __total_len == __dest_len as usize,
    "dest len must exactly match computed encoded len"
  );

  // Prepare destination and input slices up front
  let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };
  let __sl_name: &[u8] = unsafe { slice::from_raw_parts(name, 256) };

  // Build fixed header as a stack struct using an initializer expression
  let __wire: jb_agent_internal__kill_css = jb_agent_internal__kill_css {
    _rpc_id: 363 as u16,
    name: __sl_name.try_into().unwrap(),
    cgroup,
    cgroup_parent
  };

  // Copy timestamp and packed header (without struct tail padding)
  let __fixed_len = 8usize + 280 as usize;
  __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
  let __src_struct: &[u8] = unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 280 as usize) };
  __dst[8..__fixed_len].copy_from_slice(__src_struct);

  // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_css_populate_dir(
  __dest: *mut u8,
  __dest_len: u32,
  __tstamp: u64,
  cgroup: u64,
  cgroup_parent: u64,
  name: *const u8
) {
  assert!(!__dest.is_null(), "dest must not be null");

  // Compute encoded length: fixed struct size + dynamic payload
  let __consumed: u32 = 280 as u32;

  let __total_len = (8_u32).saturating_add(__consumed) as usize;
  assert!(
    __total_len == __dest_len as usize,
    "dest len must exactly match computed encoded len"
  );

  // Prepare destination and input slices up front
  let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };
  let __sl_name: &[u8] = unsafe { slice::from_raw_parts(name, 256) };

  // Build fixed header as a stack struct using an initializer expression
  let __wire: jb_agent_internal__css_populate_dir = jb_agent_internal__css_populate_dir {
    _rpc_id: 364 as u16,
    name: __sl_name.try_into().unwrap(),
    cgroup,
    cgroup_parent
  };

  // Copy timestamp and packed header (without struct tail padding)
  let __fixed_len = 8usize + 280 as usize;
  __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
  let __src_struct: &[u8] = unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 280 as usize) };
  __dst[8..__fixed_len].copy_from_slice(__src_struct);

  // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_existing_cgroup_probe(
  __dest: *mut u8,
  __dest_len: u32,
  __tstamp: u64,
  cgroup: u64,
  cgroup_parent: u64,
  name: *const u8
) {
  assert!(!__dest.is_null(), "dest must not be null");

  // Compute encoded length: fixed struct size + dynamic payload
  let __consumed: u32 = 280 as u32;

  let __total_len = (8_u32).saturating_add(__consumed) as usize;
  assert!(
    __total_len == __dest_len as usize,
    "dest len must exactly match computed encoded len"
  );

  // Prepare destination and input slices up front
  let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };
  let __sl_name: &[u8] = unsafe { slice::from_raw_parts(name, 256) };

  // Build fixed header as a stack struct using an initializer expression
  let __wire: jb_agent_internal__existing_cgroup_probe = jb_agent_internal__existing_cgroup_probe {
    _rpc_id: 365 as u16,
    name: __sl_name.try_into().unwrap(),
    cgroup,
    cgroup_parent
  };

  // Copy timestamp and packed header (without struct tail padding)
  let __fixed_len = 8usize + 280 as usize;
  __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
  let __src_struct: &[u8] = unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 280 as usize) };
  __dst[8..__fixed_len].copy_from_slice(__src_struct);

  // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_cgroup_attach_task(
  __dest: *mut u8,
  __dest_len: u32,
  __tstamp: u64,
  cgroup: u64,
  pid: u32,
  comm: *const u8
) {
  assert!(!__dest.is_null(), "dest must not be null");

  // Compute encoded length: fixed struct size + dynamic payload
  let __consumed: u32 = 32 as u32;

  let __total_len = (8_u32).saturating_add(__consumed) as usize;
  assert!(
    __total_len == __dest_len as usize,
    "dest len must exactly match computed encoded len"
  );

  // Prepare destination and input slices up front
  let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };
  let __sl_comm: &[u8] = unsafe { slice::from_raw_parts(comm, 16) };

  // Build fixed header as a stack struct using an initializer expression
  let __wire: jb_agent_internal__cgroup_attach_task = jb_agent_internal__cgroup_attach_task {
    _rpc_id: 366 as u16,
    comm: __sl_comm.try_into().unwrap(),
    pid,
    cgroup
  };

  // Copy timestamp and packed header (without struct tail padding)
  let __fixed_len = 8usize + 32 as usize;
  __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
  let __src_struct: &[u8] = unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 32 as usize) };
  __dst[8..__fixed_len].copy_from_slice(__src_struct);

  // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_nf_conntrack_alter_reply(
  __dest: *mut u8,
  __dest_len: u32,
  __tstamp: u64,
  ct: u64,
  src_ip: u32,
  src_port: u16,
  dst_ip: u32,
  dst_port: u16,
  proto: u8,
  nat_src_ip: u32,
  nat_src_port: u16,
  nat_dst_ip: u32,
  nat_dst_port: u16,
  nat_proto: u8
) {
  assert!(!__dest.is_null(), "dest must not be null");

  // Compute encoded length: fixed struct size + dynamic payload
  let __consumed: u32 = 36 as u32;

  let __total_len = (8_u32).saturating_add(__consumed) as usize;
  assert!(
    __total_len == __dest_len as usize,
    "dest len must exactly match computed encoded len"
  );

  // Prepare destination and input slices up front
  let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };

  // Build fixed header as a stack struct using an initializer expression
  let __wire: jb_agent_internal__nf_conntrack_alter_reply = jb_agent_internal__nf_conntrack_alter_reply {
    _rpc_id: 367 as u16,
    src_port,
    src_ip,
    ct,
    dst_ip,
    nat_src_ip,
    nat_dst_ip,
    dst_port,
    nat_src_port,
    nat_dst_port,
    proto,
    nat_proto
  };

  // Copy timestamp and packed header (without struct tail padding)
  let __fixed_len = 8usize + 36 as usize;
  __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
  let __src_struct: &[u8] = unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 36 as usize) };
  __dst[8..__fixed_len].copy_from_slice(__src_struct);

  // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_nf_nat_cleanup_conntrack(
  __dest: *mut u8,
  __dest_len: u32,
  __tstamp: u64,
  ct: u64,
  src_ip: u32,
  src_port: u16,
  dst_ip: u32,
  dst_port: u16,
  proto: u8
) {
  assert!(!__dest.is_null(), "dest must not be null");

  // Compute encoded length: fixed struct size + dynamic payload
  let __consumed: u32 = 23 as u32;

  let __total_len = (8_u32).saturating_add(__consumed) as usize;
  assert!(
    __total_len == __dest_len as usize,
    "dest len must exactly match computed encoded len"
  );

  // Prepare destination and input slices up front
  let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };

  // Build fixed header as a stack struct using an initializer expression
  let __wire: jb_agent_internal__nf_nat_cleanup_conntrack = jb_agent_internal__nf_nat_cleanup_conntrack {
    _rpc_id: 368 as u16,
    src_port,
    src_ip,
    ct,
    dst_ip,
    dst_port,
    proto
  };

  // Copy timestamp and packed header (without struct tail padding)
  let __fixed_len = 8usize + 23 as usize;
  __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
  let __src_struct: &[u8] = unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 23 as usize) };
  __dst[8..__fixed_len].copy_from_slice(__src_struct);

  // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_existing_conntrack_tuple(
  __dest: *mut u8,
  __dest_len: u32,
  __tstamp: u64,
  ct: u64,
  src_ip: u32,
  src_port: u16,
  dst_ip: u32,
  dst_port: u16,
  proto: u8,
  dir: u8
) {
  assert!(!__dest.is_null(), "dest must not be null");

  // Compute encoded length: fixed struct size + dynamic payload
  let __consumed: u32 = 24 as u32;

  let __total_len = (8_u32).saturating_add(__consumed) as usize;
  assert!(
    __total_len == __dest_len as usize,
    "dest len must exactly match computed encoded len"
  );

  // Prepare destination and input slices up front
  let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };

  // Build fixed header as a stack struct using an initializer expression
  let __wire: jb_agent_internal__existing_conntrack_tuple = jb_agent_internal__existing_conntrack_tuple {
    _rpc_id: 369 as u16,
    src_port,
    src_ip,
    ct,
    dst_ip,
    dst_port,
    proto,
    dir
  };

  // Copy timestamp and packed header (without struct tail padding)
  let __fixed_len = 8usize + 24 as usize;
  __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
  let __src_struct: &[u8] = unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 24 as usize) };
  __dst[8..__fixed_len].copy_from_slice(__src_struct);

  // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_tcp_syn_timeout(
  __dest: *mut u8,
  __dest_len: u32,
  __tstamp: u64,
  sk: u64
) {
  assert!(!__dest.is_null(), "dest must not be null");

  // Compute encoded length: fixed struct size + dynamic payload
  let __consumed: u32 = 16 as u32;

  let __total_len = (8_u32).saturating_add(__consumed) as usize;
  assert!(
    __total_len == __dest_len as usize,
    "dest len must exactly match computed encoded len"
  );

  // Prepare destination and input slices up front
  let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };

  // Build fixed header as a stack struct using an initializer expression
  let __wire: jb_agent_internal__tcp_syn_timeout = jb_agent_internal__tcp_syn_timeout {
    _rpc_id: 370 as u16,
    sk
  };

  // Copy timestamp and packed header (without struct tail padding)
  let __fixed_len = 8usize + 16 as usize;
  __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
  let __src_struct: &[u8] = unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 16 as usize) };
  __dst[8..__fixed_len].copy_from_slice(__src_struct);

  // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_http_response(
  __dest: *mut u8,
  __dest_len: u32,
  __tstamp: u64,
  sk: u64,
  pid: u32,
  code: u16,
  latency_ns: u64,
  client_server: u8
) {
  assert!(!__dest.is_null(), "dest must not be null");

  // Compute encoded length: fixed struct size + dynamic payload
  let __consumed: u32 = 25 as u32;

  let __total_len = (8_u32).saturating_add(__consumed) as usize;
  assert!(
    __total_len == __dest_len as usize,
    "dest len must exactly match computed encoded len"
  );

  // Prepare destination and input slices up front
  let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };

  // Build fixed header as a stack struct using an initializer expression
  let __wire: jb_agent_internal__http_response = jb_agent_internal__http_response {
    _rpc_id: 372 as u16,
    code,
    pid,
    sk,
    latency_ns,
    client_server
  };

  // Copy timestamp and packed header (without struct tail padding)
  let __fixed_len = 8usize + 25 as usize;
  __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
  let __src_struct: &[u8] = unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 25 as usize) };
  __dst[8..__fixed_len].copy_from_slice(__src_struct);

  // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_bpf_log(
  __dest: *mut u8,
  __dest_len: u32,
  __tstamp: u64,
  filelineid: u64,
  code: u64,
  arg0: u64,
  arg1: u64,
  arg2: u64
) {
  assert!(!__dest.is_null(), "dest must not be null");

  // Compute encoded length: fixed struct size + dynamic payload
  let __consumed: u32 = 48 as u32;

  let __total_len = (8_u32).saturating_add(__consumed) as usize;
  assert!(
    __total_len == __dest_len as usize,
    "dest len must exactly match computed encoded len"
  );

  // Prepare destination and input slices up front
  let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };

  // Build fixed header as a stack struct using an initializer expression
  let __wire: jb_agent_internal__bpf_log = jb_agent_internal__bpf_log {
    _rpc_id: 373 as u16,
    filelineid,
    code,
    arg0,
    arg1,
    arg2
  };

  // Copy timestamp and packed header (without struct tail padding)
  let __fixed_len = 8usize + 48 as usize;
  __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
  let __src_struct: &[u8] = unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 48 as usize) };
  __dst[8..__fixed_len].copy_from_slice(__src_struct);

  // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_stack_trace(
  __dest: *mut u8,
  __dest_len: u32,
  __tstamp: u64,
  kernel_stack_id: i32,
  user_stack_id: i32,
  tgid: u32,
  comm: *const u8
) {
  assert!(!__dest.is_null(), "dest must not be null");

  // Compute encoded length: fixed struct size + dynamic payload
  let __consumed: u32 = 32 as u32;

  let __total_len = (8_u32).saturating_add(__consumed) as usize;
  assert!(
    __total_len == __dest_len as usize,
    "dest len must exactly match computed encoded len"
  );

  // Prepare destination and input slices up front
  let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };
  let __sl_comm: &[u8] = unsafe { slice::from_raw_parts(comm, 16) };

  // Build fixed header as a stack struct using an initializer expression
  let __wire: jb_agent_internal__stack_trace = jb_agent_internal__stack_trace {
    _rpc_id: 374 as u16,
    comm: __sl_comm.try_into().unwrap(),
    kernel_stack_id,
    user_stack_id,
    tgid
  };

  // Copy timestamp and packed header (without struct tail padding)
  let __fixed_len = 8usize + 32 as usize;
  __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
  let __src_struct: &[u8] = unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 32 as usize) };
  __dst[8..__fixed_len].copy_from_slice(__src_struct);

  // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_tcp_data(
  __dest: *mut u8,
  __dest_len: u32,
  __tstamp: u64,
  sk: u64,
  pid: u32,
  length: u32,
  offset: u64,
  stream_type: u8,
  client_server: u8
) {
  assert!(!__dest.is_null(), "dest must not be null");

  // Compute encoded length: fixed struct size + dynamic payload
  let __consumed: u32 = 28 as u32;

  let __total_len = (8_u32).saturating_add(__consumed) as usize;
  assert!(
    __total_len == __dest_len as usize,
    "dest len must exactly match computed encoded len"
  );

  // Prepare destination and input slices up front
  let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };

  // Build fixed header as a stack struct using an initializer expression
  let __wire: jb_agent_internal__tcp_data = jb_agent_internal__tcp_data {
    _rpc_id: 375 as u16,
    stream_type,
    client_server,
    pid,
    sk,
    offset,
    length
  };

  // Copy timestamp and packed header (without struct tail padding)
  let __fixed_len = 8usize + 28 as usize;
  __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
  let __src_struct: &[u8] = unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 28 as usize) };
  __dst[8..__fixed_len].copy_from_slice(__src_struct);

  // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_pid_exit(
  __dest: *mut u8,
  __dest_len: u32,
  __tstamp: u64,
  tgid: u64,
  pid: u32,
  exit_code: i32
) {
  assert!(!__dest.is_null(), "dest must not be null");

  // Compute encoded length: fixed struct size + dynamic payload
  let __consumed: u32 = 20 as u32;

  let __total_len = (8_u32).saturating_add(__consumed) as usize;
  assert!(
    __total_len == __dest_len as usize,
    "dest len must exactly match computed encoded len"
  );

  // Prepare destination and input slices up front
  let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };

  // Build fixed header as a stack struct using an initializer expression
  let __wire: jb_agent_internal__pid_exit = jb_agent_internal__pid_exit {
    _rpc_id: 377 as u16,
    pid,
    tgid,
    exit_code
  };

  // Copy timestamp and packed header (without struct tail padding)
  let __fixed_len = 8usize + 20 as usize;
  __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
  let __src_struct: &[u8] = unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 20 as usize) };
  __dst[8..__fixed_len].copy_from_slice(__src_struct);

  // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_report_debug_event(
  __dest: *mut u8,
  __dest_len: u32,
  __tstamp: u64,
  event: u16,
  arg1: u64,
  arg2: u64,
  arg3: u64,
  arg4: u64
) {
  assert!(!__dest.is_null(), "dest must not be null");

  // Compute encoded length: fixed struct size + dynamic payload
  let __consumed: u32 = 40 as u32;

  let __total_len = (8_u32).saturating_add(__consumed) as usize;
  assert!(
    __total_len == __dest_len as usize,
    "dest len must exactly match computed encoded len"
  );

  // Prepare destination and input slices up front
  let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };

  // Build fixed header as a stack struct using an initializer expression
  let __wire: jb_agent_internal__report_debug_event = jb_agent_internal__report_debug_event {
    _rpc_id: 378 as u16,
    event,
    arg1,
    arg2,
    arg3,
    arg4
  };

  // Copy timestamp and packed header (without struct tail padding)
  let __fixed_len = 8usize + 40 as usize;
  __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
  let __src_struct: &[u8] = unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 40 as usize) };
  __dst[8..__fixed_len].copy_from_slice(__src_struct);

  // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_tcp_reset(
  __dest: *mut u8,
  __dest_len: u32,
  __tstamp: u64,
  sk: u64,
  is_rx: u8
) {
  assert!(!__dest.is_null(), "dest must not be null");

  // Compute encoded length: fixed struct size + dynamic payload
  let __consumed: u32 = 16 as u32;

  let __total_len = (8_u32).saturating_add(__consumed) as usize;
  assert!(
    __total_len == __dest_len as usize,
    "dest len must exactly match computed encoded len"
  );

  // Prepare destination and input slices up front
  let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };

  // Build fixed header as a stack struct using an initializer expression
  let __wire: jb_agent_internal__tcp_reset = jb_agent_internal__tcp_reset {
    _rpc_id: 379 as u16,
    is_rx,
    sk
  };

  // Copy timestamp and packed header (without struct tail padding)
  let __fixed_len = 8usize + 16 as usize;
  __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
  let __src_struct: &[u8] = unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 16 as usize) };
  __dst[8..__fixed_len].copy_from_slice(__src_struct);

  // Append dynamic payloads sequentially
}
#[no_mangle]
pub extern "C" fn ebpf_net_agent_internal_encode_pulse(
  __dest: *mut u8,
  __dest_len: u32,
  __tstamp: u64) {
  assert!(!__dest.is_null(), "dest must not be null");

  // Compute encoded length: fixed struct size + dynamic payload
  let __consumed: u32 = 2 as u32;

  let __total_len = (8_u32).saturating_add(__consumed) as usize;
  assert!(
    __total_len == __dest_len as usize,
    "dest len must exactly match computed encoded len"
  );

  // Prepare destination and input slices up front
  let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };

  // Build fixed header as a stack struct using an initializer expression
  let __wire: jb_agent_internal__pulse = jb_agent_internal__pulse {
    _rpc_id: 65535 as u16,
  };

  // Copy timestamp and packed header (without struct tail padding)
  let __fixed_len = 8usize + 2 as usize;
  __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
  let __src_struct: &[u8] = unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, 2 as usize) };
  __dst[8..__fixed_len].copy_from_slice(__src_struct);

  // Append dynamic payloads sequentially
}
