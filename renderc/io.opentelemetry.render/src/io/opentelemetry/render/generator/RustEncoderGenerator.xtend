// Copyright The OpenTelemetry Authors
// SPDX-License-Identifier: Apache-2.0

package io.opentelemetry.render.generator

import org.eclipse.xtext.generator.IFileSystemAccess2

import io.opentelemetry.render.render.App
import io.opentelemetry.render.render.Field
import io.opentelemetry.render.render.FieldTypeEnum

import static io.opentelemetry.render.generator.AppGenerator.outputPath
import static extension io.opentelemetry.render.extensions.AppExtensions.*
import static extension io.opentelemetry.render.extensions.FieldExtensions.*

/**
 * Generates for every app:
 *  - Rust FFI implementation (encoder.rs) building the fixed header on a
 *    64-bit aligned stack buffer (like C++), then copying only the used
 *    bytes (timestamp + packed header without tail padding) to the channel
 *    buffer before appending dynamic string payloads.
 */
class RustEncoderGenerator {

  def void doGenerate(App app, IFileSystemAccess2 fsa) {
    fsa.generateFile(outputPath(app, "encoder.rs"), generateRustEncoder(app))
  }

  private static def generateRustEncoder(App app) {
    '''
    // Auto-generated by Render: Rust FFI for «app.pkg.name»::«app.name»
    #[allow(non_camel_case_types)]
    #[allow(non_snake_case)]
    #[allow(unused_variables)]

    #[allow(unused_imports)]
    use crate::JbBlob;
    
    use crate::wire_messages::*;

    use core::slice;

    «FOR msg : app.messages»
      #[no_mangle]
      pub extern "C" fn «app.pkg.name»_«app.name»_encode_«msg.name»(
        __dest: *mut u8,
        __dest_len: u32,
        __tstamp: u64«FOR field : msg.fields.sortBy[id] BEFORE ',' SEPARATOR ','»
          «rustParam(field)»
        «ENDFOR»
      ) {
        assert!(!__dest.is_null(), "dest must not be null");

        // Compute encoded length: fixed struct size + dynamic payload
        «IF msg.wire_msg.dynamic_size»
          let mut __consumed: u32 = «msg.wire_msg.size» as u32;
          «FOR field : msg.wire_msg.fields.filter[type.enum_type == FieldTypeEnum.STRING]»
            __consumed = __consumed.saturating_add(«field.name».len as u32);
          «ENDFOR»
          __consumed = __consumed.saturating_add(«msg.wire_msg.last_blob_field.name».len as u32);
          assert!(__consumed <= 0xffff, "encoded len must fit in u16");
        «ELSE»
          let __consumed: u32 = «msg.wire_msg.size» as u32;
        «ENDIF»

        let __total_len = (8_u32).saturating_add(__consumed) as usize;
        assert!(
          __total_len == __dest_len as usize,
          "dest len must exactly match computed encoded len"
        );

        // Prepare destination and input slices up front
        let __dst: &mut [u8] = unsafe { slice::from_raw_parts_mut(__dest, __dest_len as usize) };
        «FOR field : msg.fields.filter[type.enum_type == FieldTypeEnum.STRING]»
          let __sl_«field.name»: &[u8] = unsafe { slice::from_raw_parts(«field.name».buf as *const u8, «field.name».len as usize) };
        «ENDFOR»
        «FOR field : msg.fields.filter[type.isShortString]»
          let __sl_«field.name»: &[u8] = unsafe { slice::from_raw_parts(«field.name», «field.size(true)») };
        «ENDFOR»
        «FOR field : msg.fields.filter[isArray && !type.isShortString && type.enum_type != FieldTypeEnum.STRING]»
          let __sl_«field.name»: &[«rustScalarType(field)»] = unsafe { slice::from_raw_parts(«field.name», «field.array_size») };
        «ENDFOR»

        // Build fixed header as a stack struct using an initializer expression
        let __wire: «msg.wire_msg.struct_name» = «msg.wire_msg.struct_name» {
          _rpc_id: «msg.wire_msg.rpc_id» as u16,
          «IF msg.wire_msg.dynamic_size»
            _len: __consumed as u16,
          «ENDIF»
          «FOR field : msg.wire_msg.fields SEPARATOR ","»
            «IF field.isArray && field.type.isShortString»
              «field.name»: {
                let mut __tmp = [[0u8; «field.type.size»]; «field.array_size»];
                let __elem_len = «field.type.size»;
                for (__i, __chunk) in __sl_«field.name».chunks_exact(__elem_len).enumerate() {
                  __tmp[__i].copy_from_slice(__chunk);
                }
                __tmp
              }
            «ELSEIF field.isArray || field.type.isShortString»
              «field.name»: __sl_«field.name».try_into().unwrap()
            «ELSEIF field.type.enum_type == FieldTypeEnum.STRING»
              «field.name»: (__sl_«field.name».len() as u16)
            «ELSE»
              «field.name»
            «ENDIF»
          «ENDFOR»
        };

        // Copy timestamp and packed header (without struct tail padding)
        let __fixed_len = 8usize + «msg.wire_msg.size» as usize;
        __dst[..8].copy_from_slice(&__tstamp.to_ne_bytes());
        let __src_struct: &[u8] = unsafe { slice::from_raw_parts(&__wire as *const _ as *const u8, «msg.wire_msg.size» as usize) };
        __dst[8..__fixed_len].copy_from_slice(__src_struct);

        // Append dynamic payloads sequentially
        «IF msg.wire_msg.dynamic_size»
          let mut __off = __fixed_len;
          «FOR field : msg.wire_msg.fields.filter[type.enum_type == FieldTypeEnum.STRING] + #[msg.wire_msg.last_blob_field]»
            if !__sl_«field.name».is_empty() {
              let __len = __sl_«field.name».len();
              let __dst_seg = &mut __dst[__off .. __off + __len];
              __dst_seg.copy_from_slice(__sl_«field.name»);
              __off += __len;
            }
          «ENDFOR»
        «ENDIF»
      }
    «ENDFOR»
    '''
  }

  private static def String rustParam(Field field) {
    if (field.type.enum_type == FieldTypeEnum.STRING) {
      return '''«field.name»: JbBlob'''
    }
    if (field.type.isShortString || field.isArray) {
      val elem = rustScalarType(field)
      return '''«field.name»: *const «elem»'''
    }
    return '''«field.name»: «rustScalarType(field)»'''
  }

  private static def String rustScalarType(Field field) {
    switch (field.type.enum_type) {
      case FieldTypeEnum.U8: 'u8'
      case FieldTypeEnum.U16: 'u16'
      case FieldTypeEnum.U32: 'u32'
      case FieldTypeEnum.U64: 'u64'
      case FieldTypeEnum.U128: 'u128'
      case FieldTypeEnum.S8: 'i8'
      case FieldTypeEnum.S16: 'i16'
      case FieldTypeEnum.S32: 'i32'
      case FieldTypeEnum.S64: 'i64'
      case FieldTypeEnum.S128: 'i128'
      case FieldTypeEnum.STRING: 'u16' // not used here
    }
  }
}
